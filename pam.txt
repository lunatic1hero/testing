import json
import re
import urllib.parse
from flask import Flask, request, render_template, redirect, url_for, session, flash
import pandas as pd
from pycaret.clustering import load_model, predict_model

app = Flask(__name__)
app.secret_key = 'your_secret_key'  # Replace with a secure secret key

# Load pre-trained K-Means model
model = load_model('kmeans_model')

# Load the existing clustered data
clustered_data_path = 'clustered_results_with_features.csv'
clustered_data = pd.read_csv(clustered_data_path)

# Define SQL keywords globally
sql_keywords = [
    'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER', 'TRUNCATE',
    'UNION', 'FROM', 'WHERE', 'AND', 'OR', 'LIKE', 'BETWEEN', 'IN', 'JOIN', 'ON', 'GROUP BY', 'ORDER BY', 'HAVING', 'LIMIT'
]

# XSS patterns
xss_patterns = [
    r'<script', r'alert\(', r'\(alert\(', r'</script>', r'document\.cookie', r'eval\(', r'window\.location', 
    r'setTimeout\(', r'setInterval\(', r'execCommand', r'innerHTML', r'outerHTML', r'document\.write', 
    r'XMLHttpRequest\.open', r'FormData\.append', r'document\.getElementById', r'document\.createElement', 
    r'document\.execCommand', r'window\.open', r'window\.eval', r'window\.setTimeout', r'window\.setInterval', 
    r'document\.URL', r'location\.href', r'location\.search', r'document\.referrer', r'navigator\.sendBeacon', 
    r'importScripts', r'`'
]

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/admin')
def admin():
    if not session.get('logged_in'):
        return redirect(url_for('login'))
    return render_template('admin.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if username == 'admin' and password == 'password':  # Replace with a proper authentication mechanism
            session['logged_in'] = True
            return redirect(url_for('admin'))
        else:
            flash('Invalid credentials')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    return redirect(url_for('index'))

def extract_features(req_data):
    '''
    Extract features from HTTP request for clustering and security analysis.
    '''
    request_method = req_data.method
    request_url = urllib.parse.unquote(req_data.url)
    request_headers = {k: v for k, v in req_data.headers}
    request_body = req_data.form.to_dict()

    # Initialize features with default values
    features = {
        'method': request_method,
        'path': request_url,
        'headers': str(request_headers),
        'body': '',
        'body_length': 0,
        'num_commas': 0,
        'num_hyphens': 0,
        'num_brackets': 0,
        'num_quotes': 0,
        'num_double_quotes': 0,
        'num_slashes': 0,
        'num_braces': 0,
        'num_spaces': 0,
        'has_sql_keywords': 0,
        'has_xss_payload': 0,
        'has_csrf_token': 0,
        'response_status': 200,  # Placeholder value
        'response_time': 0       # Placeholder value
    }

    uid_value = request_body.get('uid', '')

    if uid_value:
        features['body'] = uid_value
        features['body_length'] = len(uid_value)
        features['num_commas'] = uid_value.count(',')
        features['num_hyphens'] = uid_value.count('-')
        features['num_brackets'] = uid_value.count('(') + uid_value.count(')')
        features['num_quotes'] = uid_value.count("'")
        features['num_double_quotes'] = uid_value.count('"')
        features['num_slashes'] = uid_value.count('/')
        features['num_braces'] = uid_value.count('{') + uid_value.count('}')
        features['num_spaces'] = uid_value.count(' ')

        # Check for SQL keywords in the UID value (case-insensitive)
        uid_value_lower = uid_value.lower()
        features['has_sql_keywords'] = int(any(keyword.lower() in uid_value_lower for keyword in sql_keywords))

    # Check for XSS payload in URL and headers
    features['has_xss_payload'] = detect_xss_payload(request_url.lower(), str(request_headers), xss_patterns)

    # Check for CSRF token presence in headers
    csrf_keywords = ['csrf_token', 'anti_csrf_token', 'xsrf_token']
    csrf_pattern = r'\b({})\b'.format('|'.join(csrf_keywords))
    features['has_csrf_token'] = int(any(re.search(csrf_pattern, str(request_headers).lower()) for key in csrf_keywords))

    return features

def detect_xss_payload(request_url, request_headers, xss_patterns):
    '''
    Detects XSS payloads in the request URL and headers using specified patterns.
    '''
    decoded_url = urllib.parse.unquote(urllib.parse.unquote(request_url))
    for pattern in xss_patterns:
        if re.search(pattern, decoded_url, re.IGNORECASE) or re.search(pattern, request_headers, re.IGNORECASE):
            return 1
    return 0

@app.route('/submit', methods=['POST'])
def submit():
    req_data = request
    features = extract_features(req_data)
    features['nature'] = 'new req'
    new_request_df = pd.DataFrame([features])

    # Cluster the new request
    predictions = predict_model(model, data=new_request_df)
    new_request_df['Cluster'] = predictions['Cluster']

    # Add new request to the clustered data
    global clustered_data
    clustered_data = clustered_data.append(new_request_df, ignore_index=True)
    clustered_data.to_csv(clustered_data_path, index=False)

    # Check if the new request's cluster has fewer entries than a threshold
    threshold = 5
    cluster_counts = clustered_data['Cluster'].value_counts()
    new_request_cluster = new_request_df.iloc[0]['Cluster']
    if cluster_counts[new_request_cluster] <= threshold:
        flash('Potential intrusion detected!')

    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(debug=True)

